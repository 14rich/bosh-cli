// This file was generated by counterfeiter
package vmfakes

import (
	"sync"
	"time"

	"github.com/cloudfoundry/bosh-agent/agentclient"
	"github.com/cloudfoundry/bosh-agent/agentclient/applyspec"
	"github.com/cloudfoundry/bosh-cli/deployment/disk"
	"github.com/cloudfoundry/bosh-cli/deployment/manifest"
	"github.com/cloudfoundry/bosh-cli/deployment/vm"
	"github.com/cloudfoundry/bosh-cli/ui"
)

type FakeVM struct {
	CIDStub        func() string
	cIDMutex       sync.RWMutex
	cIDArgsForCall []struct{}
	cIDReturns     struct {
		result1 string
	}
	ExistsStub        func() (bool, error)
	existsMutex       sync.RWMutex
	existsArgsForCall []struct{}
	existsReturns     struct {
		result1 bool
		result2 error
	}
	AgentClientStub        func() agentclient.AgentClient
	agentClientMutex       sync.RWMutex
	agentClientArgsForCall []struct{}
	agentClientReturns     struct {
		result1 agentclient.AgentClient
	}
	WaitUntilReadyStub        func(timeout time.Duration, delay time.Duration) error
	waitUntilReadyMutex       sync.RWMutex
	waitUntilReadyArgsForCall []struct {
		timeout time.Duration
		delay   time.Duration
	}
	waitUntilReadyReturns struct {
		result1 error
	}
	StartStub        func() error
	startMutex       sync.RWMutex
	startArgsForCall []struct{}
	startReturns     struct {
		result1 error
	}
	StopStub        func() error
	stopMutex       sync.RWMutex
	stopArgsForCall []struct{}
	stopReturns     struct {
		result1 error
	}
	ApplyStub        func(applyspec.ApplySpec) error
	applyMutex       sync.RWMutex
	applyArgsForCall []struct {
		arg1 applyspec.ApplySpec
	}
	applyReturns struct {
		result1 error
	}
	UpdateDisksStub        func(manifest.DiskPool, ui.Stage) ([]disk.Disk, error)
	updateDisksMutex       sync.RWMutex
	updateDisksArgsForCall []struct {
		arg1 manifest.DiskPool
		arg2 ui.Stage
	}
	updateDisksReturns struct {
		result1 []disk.Disk
		result2 error
	}
	WaitToBeRunningStub        func(maxAttempts int, delay time.Duration) error
	waitToBeRunningMutex       sync.RWMutex
	waitToBeRunningArgsForCall []struct {
		maxAttempts int
		delay       time.Duration
	}
	waitToBeRunningReturns struct {
		result1 error
	}
	AttachDiskStub        func(disk.Disk) error
	attachDiskMutex       sync.RWMutex
	attachDiskArgsForCall []struct {
		arg1 disk.Disk
	}
	attachDiskReturns struct {
		result1 error
	}
	DetachDiskStub        func(disk.Disk) error
	detachDiskMutex       sync.RWMutex
	detachDiskArgsForCall []struct {
		arg1 disk.Disk
	}
	detachDiskReturns struct {
		result1 error
	}
	DisksStub        func() ([]disk.Disk, error)
	disksMutex       sync.RWMutex
	disksArgsForCall []struct{}
	disksReturns     struct {
		result1 []disk.Disk
		result2 error
	}
	UnmountDiskStub        func(disk.Disk) error
	unmountDiskMutex       sync.RWMutex
	unmountDiskArgsForCall []struct {
		arg1 disk.Disk
	}
	unmountDiskReturns struct {
		result1 error
	}
	MigrateDiskStub        func() error
	migrateDiskMutex       sync.RWMutex
	migrateDiskArgsForCall []struct{}
	migrateDiskReturns     struct {
		result1 error
	}
	RunScriptStub        func(script string, options map[string]interface{}) error
	runScriptMutex       sync.RWMutex
	runScriptArgsForCall []struct {
		script  string
		options map[string]interface{}
	}
	runScriptReturns struct {
		result1 error
	}
	DeleteStub        func() error
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct{}
	deleteReturns     struct {
		result1 error
	}
	GetStateStub        func() (agentclient.AgentState, error)
	getStateMutex       sync.RWMutex
	getStateArgsForCall []struct{}
	getStateReturns     struct {
		result1 agentclient.AgentState
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeVM) CID() string {
	fake.cIDMutex.Lock()
	fake.cIDArgsForCall = append(fake.cIDArgsForCall, struct{}{})
	fake.recordInvocation("CID", []interface{}{})
	fake.cIDMutex.Unlock()
	if fake.CIDStub != nil {
		return fake.CIDStub()
	} else {
		return fake.cIDReturns.result1
	}
}

func (fake *FakeVM) CIDCallCount() int {
	fake.cIDMutex.RLock()
	defer fake.cIDMutex.RUnlock()
	return len(fake.cIDArgsForCall)
}

func (fake *FakeVM) CIDReturns(result1 string) {
	fake.CIDStub = nil
	fake.cIDReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeVM) Exists() (bool, error) {
	fake.existsMutex.Lock()
	fake.existsArgsForCall = append(fake.existsArgsForCall, struct{}{})
	fake.recordInvocation("Exists", []interface{}{})
	fake.existsMutex.Unlock()
	if fake.ExistsStub != nil {
		return fake.ExistsStub()
	} else {
		return fake.existsReturns.result1, fake.existsReturns.result2
	}
}

func (fake *FakeVM) ExistsCallCount() int {
	fake.existsMutex.RLock()
	defer fake.existsMutex.RUnlock()
	return len(fake.existsArgsForCall)
}

func (fake *FakeVM) ExistsReturns(result1 bool, result2 error) {
	fake.ExistsStub = nil
	fake.existsReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeVM) AgentClient() agentclient.AgentClient {
	fake.agentClientMutex.Lock()
	fake.agentClientArgsForCall = append(fake.agentClientArgsForCall, struct{}{})
	fake.recordInvocation("AgentClient", []interface{}{})
	fake.agentClientMutex.Unlock()
	if fake.AgentClientStub != nil {
		return fake.AgentClientStub()
	} else {
		return fake.agentClientReturns.result1
	}
}

func (fake *FakeVM) AgentClientCallCount() int {
	fake.agentClientMutex.RLock()
	defer fake.agentClientMutex.RUnlock()
	return len(fake.agentClientArgsForCall)
}

func (fake *FakeVM) AgentClientReturns(result1 agentclient.AgentClient) {
	fake.AgentClientStub = nil
	fake.agentClientReturns = struct {
		result1 agentclient.AgentClient
	}{result1}
}

func (fake *FakeVM) WaitUntilReady(timeout time.Duration, delay time.Duration) error {
	fake.waitUntilReadyMutex.Lock()
	fake.waitUntilReadyArgsForCall = append(fake.waitUntilReadyArgsForCall, struct {
		timeout time.Duration
		delay   time.Duration
	}{timeout, delay})
	fake.recordInvocation("WaitUntilReady", []interface{}{timeout, delay})
	fake.waitUntilReadyMutex.Unlock()
	if fake.WaitUntilReadyStub != nil {
		return fake.WaitUntilReadyStub(timeout, delay)
	} else {
		return fake.waitUntilReadyReturns.result1
	}
}

func (fake *FakeVM) WaitUntilReadyCallCount() int {
	fake.waitUntilReadyMutex.RLock()
	defer fake.waitUntilReadyMutex.RUnlock()
	return len(fake.waitUntilReadyArgsForCall)
}

func (fake *FakeVM) WaitUntilReadyArgsForCall(i int) (time.Duration, time.Duration) {
	fake.waitUntilReadyMutex.RLock()
	defer fake.waitUntilReadyMutex.RUnlock()
	return fake.waitUntilReadyArgsForCall[i].timeout, fake.waitUntilReadyArgsForCall[i].delay
}

func (fake *FakeVM) WaitUntilReadyReturns(result1 error) {
	fake.WaitUntilReadyStub = nil
	fake.waitUntilReadyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeVM) Start() error {
	fake.startMutex.Lock()
	fake.startArgsForCall = append(fake.startArgsForCall, struct{}{})
	fake.recordInvocation("Start", []interface{}{})
	fake.startMutex.Unlock()
	if fake.StartStub != nil {
		return fake.StartStub()
	} else {
		return fake.startReturns.result1
	}
}

func (fake *FakeVM) StartCallCount() int {
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	return len(fake.startArgsForCall)
}

func (fake *FakeVM) StartReturns(result1 error) {
	fake.StartStub = nil
	fake.startReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeVM) Stop() error {
	fake.stopMutex.Lock()
	fake.stopArgsForCall = append(fake.stopArgsForCall, struct{}{})
	fake.recordInvocation("Stop", []interface{}{})
	fake.stopMutex.Unlock()
	if fake.StopStub != nil {
		return fake.StopStub()
	} else {
		return fake.stopReturns.result1
	}
}

func (fake *FakeVM) StopCallCount() int {
	fake.stopMutex.RLock()
	defer fake.stopMutex.RUnlock()
	return len(fake.stopArgsForCall)
}

func (fake *FakeVM) StopReturns(result1 error) {
	fake.StopStub = nil
	fake.stopReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeVM) Apply(arg1 applyspec.ApplySpec) error {
	fake.applyMutex.Lock()
	fake.applyArgsForCall = append(fake.applyArgsForCall, struct {
		arg1 applyspec.ApplySpec
	}{arg1})
	fake.recordInvocation("Apply", []interface{}{arg1})
	fake.applyMutex.Unlock()
	if fake.ApplyStub != nil {
		return fake.ApplyStub(arg1)
	} else {
		return fake.applyReturns.result1
	}
}

func (fake *FakeVM) ApplyCallCount() int {
	fake.applyMutex.RLock()
	defer fake.applyMutex.RUnlock()
	return len(fake.applyArgsForCall)
}

func (fake *FakeVM) ApplyArgsForCall(i int) applyspec.ApplySpec {
	fake.applyMutex.RLock()
	defer fake.applyMutex.RUnlock()
	return fake.applyArgsForCall[i].arg1
}

func (fake *FakeVM) ApplyReturns(result1 error) {
	fake.ApplyStub = nil
	fake.applyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeVM) UpdateDisks(arg1 manifest.DiskPool, arg2 ui.Stage) ([]disk.Disk, error) {
	fake.updateDisksMutex.Lock()
	fake.updateDisksArgsForCall = append(fake.updateDisksArgsForCall, struct {
		arg1 manifest.DiskPool
		arg2 ui.Stage
	}{arg1, arg2})
	fake.recordInvocation("UpdateDisks", []interface{}{arg1, arg2})
	fake.updateDisksMutex.Unlock()
	if fake.UpdateDisksStub != nil {
		return fake.UpdateDisksStub(arg1, arg2)
	} else {
		return fake.updateDisksReturns.result1, fake.updateDisksReturns.result2
	}
}

func (fake *FakeVM) UpdateDisksCallCount() int {
	fake.updateDisksMutex.RLock()
	defer fake.updateDisksMutex.RUnlock()
	return len(fake.updateDisksArgsForCall)
}

func (fake *FakeVM) UpdateDisksArgsForCall(i int) (manifest.DiskPool, ui.Stage) {
	fake.updateDisksMutex.RLock()
	defer fake.updateDisksMutex.RUnlock()
	return fake.updateDisksArgsForCall[i].arg1, fake.updateDisksArgsForCall[i].arg2
}

func (fake *FakeVM) UpdateDisksReturns(result1 []disk.Disk, result2 error) {
	fake.UpdateDisksStub = nil
	fake.updateDisksReturns = struct {
		result1 []disk.Disk
		result2 error
	}{result1, result2}
}

func (fake *FakeVM) WaitToBeRunning(maxAttempts int, delay time.Duration) error {
	fake.waitToBeRunningMutex.Lock()
	fake.waitToBeRunningArgsForCall = append(fake.waitToBeRunningArgsForCall, struct {
		maxAttempts int
		delay       time.Duration
	}{maxAttempts, delay})
	fake.recordInvocation("WaitToBeRunning", []interface{}{maxAttempts, delay})
	fake.waitToBeRunningMutex.Unlock()
	if fake.WaitToBeRunningStub != nil {
		return fake.WaitToBeRunningStub(maxAttempts, delay)
	} else {
		return fake.waitToBeRunningReturns.result1
	}
}

func (fake *FakeVM) WaitToBeRunningCallCount() int {
	fake.waitToBeRunningMutex.RLock()
	defer fake.waitToBeRunningMutex.RUnlock()
	return len(fake.waitToBeRunningArgsForCall)
}

func (fake *FakeVM) WaitToBeRunningArgsForCall(i int) (int, time.Duration) {
	fake.waitToBeRunningMutex.RLock()
	defer fake.waitToBeRunningMutex.RUnlock()
	return fake.waitToBeRunningArgsForCall[i].maxAttempts, fake.waitToBeRunningArgsForCall[i].delay
}

func (fake *FakeVM) WaitToBeRunningReturns(result1 error) {
	fake.WaitToBeRunningStub = nil
	fake.waitToBeRunningReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeVM) AttachDisk(arg1 disk.Disk) error {
	fake.attachDiskMutex.Lock()
	fake.attachDiskArgsForCall = append(fake.attachDiskArgsForCall, struct {
		arg1 disk.Disk
	}{arg1})
	fake.recordInvocation("AttachDisk", []interface{}{arg1})
	fake.attachDiskMutex.Unlock()
	if fake.AttachDiskStub != nil {
		return fake.AttachDiskStub(arg1)
	} else {
		return fake.attachDiskReturns.result1
	}
}

func (fake *FakeVM) AttachDiskCallCount() int {
	fake.attachDiskMutex.RLock()
	defer fake.attachDiskMutex.RUnlock()
	return len(fake.attachDiskArgsForCall)
}

func (fake *FakeVM) AttachDiskArgsForCall(i int) disk.Disk {
	fake.attachDiskMutex.RLock()
	defer fake.attachDiskMutex.RUnlock()
	return fake.attachDiskArgsForCall[i].arg1
}

func (fake *FakeVM) AttachDiskReturns(result1 error) {
	fake.AttachDiskStub = nil
	fake.attachDiskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeVM) DetachDisk(arg1 disk.Disk) error {
	fake.detachDiskMutex.Lock()
	fake.detachDiskArgsForCall = append(fake.detachDiskArgsForCall, struct {
		arg1 disk.Disk
	}{arg1})
	fake.recordInvocation("DetachDisk", []interface{}{arg1})
	fake.detachDiskMutex.Unlock()
	if fake.DetachDiskStub != nil {
		return fake.DetachDiskStub(arg1)
	} else {
		return fake.detachDiskReturns.result1
	}
}

func (fake *FakeVM) DetachDiskCallCount() int {
	fake.detachDiskMutex.RLock()
	defer fake.detachDiskMutex.RUnlock()
	return len(fake.detachDiskArgsForCall)
}

func (fake *FakeVM) DetachDiskArgsForCall(i int) disk.Disk {
	fake.detachDiskMutex.RLock()
	defer fake.detachDiskMutex.RUnlock()
	return fake.detachDiskArgsForCall[i].arg1
}

func (fake *FakeVM) DetachDiskReturns(result1 error) {
	fake.DetachDiskStub = nil
	fake.detachDiskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeVM) Disks() ([]disk.Disk, error) {
	fake.disksMutex.Lock()
	fake.disksArgsForCall = append(fake.disksArgsForCall, struct{}{})
	fake.recordInvocation("Disks", []interface{}{})
	fake.disksMutex.Unlock()
	if fake.DisksStub != nil {
		return fake.DisksStub()
	} else {
		return fake.disksReturns.result1, fake.disksReturns.result2
	}
}

func (fake *FakeVM) DisksCallCount() int {
	fake.disksMutex.RLock()
	defer fake.disksMutex.RUnlock()
	return len(fake.disksArgsForCall)
}

func (fake *FakeVM) DisksReturns(result1 []disk.Disk, result2 error) {
	fake.DisksStub = nil
	fake.disksReturns = struct {
		result1 []disk.Disk
		result2 error
	}{result1, result2}
}

func (fake *FakeVM) UnmountDisk(arg1 disk.Disk) error {
	fake.unmountDiskMutex.Lock()
	fake.unmountDiskArgsForCall = append(fake.unmountDiskArgsForCall, struct {
		arg1 disk.Disk
	}{arg1})
	fake.recordInvocation("UnmountDisk", []interface{}{arg1})
	fake.unmountDiskMutex.Unlock()
	if fake.UnmountDiskStub != nil {
		return fake.UnmountDiskStub(arg1)
	} else {
		return fake.unmountDiskReturns.result1
	}
}

func (fake *FakeVM) UnmountDiskCallCount() int {
	fake.unmountDiskMutex.RLock()
	defer fake.unmountDiskMutex.RUnlock()
	return len(fake.unmountDiskArgsForCall)
}

func (fake *FakeVM) UnmountDiskArgsForCall(i int) disk.Disk {
	fake.unmountDiskMutex.RLock()
	defer fake.unmountDiskMutex.RUnlock()
	return fake.unmountDiskArgsForCall[i].arg1
}

func (fake *FakeVM) UnmountDiskReturns(result1 error) {
	fake.UnmountDiskStub = nil
	fake.unmountDiskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeVM) MigrateDisk() error {
	fake.migrateDiskMutex.Lock()
	fake.migrateDiskArgsForCall = append(fake.migrateDiskArgsForCall, struct{}{})
	fake.recordInvocation("MigrateDisk", []interface{}{})
	fake.migrateDiskMutex.Unlock()
	if fake.MigrateDiskStub != nil {
		return fake.MigrateDiskStub()
	} else {
		return fake.migrateDiskReturns.result1
	}
}

func (fake *FakeVM) MigrateDiskCallCount() int {
	fake.migrateDiskMutex.RLock()
	defer fake.migrateDiskMutex.RUnlock()
	return len(fake.migrateDiskArgsForCall)
}

func (fake *FakeVM) MigrateDiskReturns(result1 error) {
	fake.MigrateDiskStub = nil
	fake.migrateDiskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeVM) RunScript(script string, options map[string]interface{}) error {
	fake.runScriptMutex.Lock()
	fake.runScriptArgsForCall = append(fake.runScriptArgsForCall, struct {
		script  string
		options map[string]interface{}
	}{script, options})
	fake.recordInvocation("RunScript", []interface{}{script, options})
	fake.runScriptMutex.Unlock()
	if fake.RunScriptStub != nil {
		return fake.RunScriptStub(script, options)
	} else {
		return fake.runScriptReturns.result1
	}
}

func (fake *FakeVM) RunScriptCallCount() int {
	fake.runScriptMutex.RLock()
	defer fake.runScriptMutex.RUnlock()
	return len(fake.runScriptArgsForCall)
}

func (fake *FakeVM) RunScriptArgsForCall(i int) (string, map[string]interface{}) {
	fake.runScriptMutex.RLock()
	defer fake.runScriptMutex.RUnlock()
	return fake.runScriptArgsForCall[i].script, fake.runScriptArgsForCall[i].options
}

func (fake *FakeVM) RunScriptReturns(result1 error) {
	fake.RunScriptStub = nil
	fake.runScriptReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeVM) Delete() error {
	fake.deleteMutex.Lock()
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct{}{})
	fake.recordInvocation("Delete", []interface{}{})
	fake.deleteMutex.Unlock()
	if fake.DeleteStub != nil {
		return fake.DeleteStub()
	} else {
		return fake.deleteReturns.result1
	}
}

func (fake *FakeVM) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *FakeVM) DeleteReturns(result1 error) {
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeVM) GetState() (agentclient.AgentState, error) {
	fake.getStateMutex.Lock()
	fake.getStateArgsForCall = append(fake.getStateArgsForCall, struct{}{})
	fake.recordInvocation("GetState", []interface{}{})
	fake.getStateMutex.Unlock()
	if fake.GetStateStub != nil {
		return fake.GetStateStub()
	} else {
		return fake.getStateReturns.result1, fake.getStateReturns.result2
	}
}

func (fake *FakeVM) GetStateCallCount() int {
	fake.getStateMutex.RLock()
	defer fake.getStateMutex.RUnlock()
	return len(fake.getStateArgsForCall)
}

func (fake *FakeVM) GetStateReturns(result1 agentclient.AgentState, result2 error) {
	fake.GetStateStub = nil
	fake.getStateReturns = struct {
		result1 agentclient.AgentState
		result2 error
	}{result1, result2}
}

func (fake *FakeVM) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.cIDMutex.RLock()
	defer fake.cIDMutex.RUnlock()
	fake.existsMutex.RLock()
	defer fake.existsMutex.RUnlock()
	fake.agentClientMutex.RLock()
	defer fake.agentClientMutex.RUnlock()
	fake.waitUntilReadyMutex.RLock()
	defer fake.waitUntilReadyMutex.RUnlock()
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	fake.stopMutex.RLock()
	defer fake.stopMutex.RUnlock()
	fake.applyMutex.RLock()
	defer fake.applyMutex.RUnlock()
	fake.updateDisksMutex.RLock()
	defer fake.updateDisksMutex.RUnlock()
	fake.waitToBeRunningMutex.RLock()
	defer fake.waitToBeRunningMutex.RUnlock()
	fake.attachDiskMutex.RLock()
	defer fake.attachDiskMutex.RUnlock()
	fake.detachDiskMutex.RLock()
	defer fake.detachDiskMutex.RUnlock()
	fake.disksMutex.RLock()
	defer fake.disksMutex.RUnlock()
	fake.unmountDiskMutex.RLock()
	defer fake.unmountDiskMutex.RUnlock()
	fake.migrateDiskMutex.RLock()
	defer fake.migrateDiskMutex.RUnlock()
	fake.runScriptMutex.RLock()
	defer fake.runScriptMutex.RUnlock()
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	fake.getStateMutex.RLock()
	defer fake.getStateMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeVM) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ vm.VM = new(FakeVM)
