// This file was generated by counterfeiter
package deploymentfakes

import (
	"sync"

	"github.com/cloudfoundry/bosh-cli/deployment"
	"github.com/cloudfoundry/bosh-cli/release"
	"github.com/cloudfoundry/bosh-cli/stemcell"
)

type FakeRecord struct {
	IsDeployedStub        func(manifestSHA string, releases []release.Release, stemcell stemcell.ExtractedStemcell) (bool, error)
	isDeployedMutex       sync.RWMutex
	isDeployedArgsForCall []struct {
		manifestSHA string
		releases    []release.Release
		stemcell    stemcell.ExtractedStemcell
	}
	isDeployedReturns struct {
		result1 bool
		result2 error
	}
	ClearStub        func() error
	clearMutex       sync.RWMutex
	clearArgsForCall []struct{}
	clearReturns     struct {
		result1 error
	}
	UpdateStub        func(manifestSHA string, releases []release.Release) error
	updateMutex       sync.RWMutex
	updateArgsForCall []struct {
		manifestSHA string
		releases    []release.Release
	}
	updateReturns struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeRecord) IsDeployed(manifestSHA string, releases []release.Release, stemcell stemcell.ExtractedStemcell) (bool, error) {
	var releasesCopy []release.Release
	if releases != nil {
		releasesCopy = make([]release.Release, len(releases))
		copy(releasesCopy, releases)
	}
	fake.isDeployedMutex.Lock()
	fake.isDeployedArgsForCall = append(fake.isDeployedArgsForCall, struct {
		manifestSHA string
		releases    []release.Release
		stemcell    stemcell.ExtractedStemcell
	}{manifestSHA, releasesCopy, stemcell})
	fake.recordInvocation("IsDeployed", []interface{}{manifestSHA, releasesCopy, stemcell})
	fake.isDeployedMutex.Unlock()
	if fake.IsDeployedStub != nil {
		return fake.IsDeployedStub(manifestSHA, releases, stemcell)
	} else {
		return fake.isDeployedReturns.result1, fake.isDeployedReturns.result2
	}
}

func (fake *FakeRecord) IsDeployedCallCount() int {
	fake.isDeployedMutex.RLock()
	defer fake.isDeployedMutex.RUnlock()
	return len(fake.isDeployedArgsForCall)
}

func (fake *FakeRecord) IsDeployedArgsForCall(i int) (string, []release.Release, stemcell.ExtractedStemcell) {
	fake.isDeployedMutex.RLock()
	defer fake.isDeployedMutex.RUnlock()
	return fake.isDeployedArgsForCall[i].manifestSHA, fake.isDeployedArgsForCall[i].releases, fake.isDeployedArgsForCall[i].stemcell
}

func (fake *FakeRecord) IsDeployedReturns(result1 bool, result2 error) {
	fake.IsDeployedStub = nil
	fake.isDeployedReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeRecord) Clear() error {
	fake.clearMutex.Lock()
	fake.clearArgsForCall = append(fake.clearArgsForCall, struct{}{})
	fake.recordInvocation("Clear", []interface{}{})
	fake.clearMutex.Unlock()
	if fake.ClearStub != nil {
		return fake.ClearStub()
	} else {
		return fake.clearReturns.result1
	}
}

func (fake *FakeRecord) ClearCallCount() int {
	fake.clearMutex.RLock()
	defer fake.clearMutex.RUnlock()
	return len(fake.clearArgsForCall)
}

func (fake *FakeRecord) ClearReturns(result1 error) {
	fake.ClearStub = nil
	fake.clearReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRecord) Update(manifestSHA string, releases []release.Release) error {
	var releasesCopy []release.Release
	if releases != nil {
		releasesCopy = make([]release.Release, len(releases))
		copy(releasesCopy, releases)
	}
	fake.updateMutex.Lock()
	fake.updateArgsForCall = append(fake.updateArgsForCall, struct {
		manifestSHA string
		releases    []release.Release
	}{manifestSHA, releasesCopy})
	fake.recordInvocation("Update", []interface{}{manifestSHA, releasesCopy})
	fake.updateMutex.Unlock()
	if fake.UpdateStub != nil {
		return fake.UpdateStub(manifestSHA, releases)
	} else {
		return fake.updateReturns.result1
	}
}

func (fake *FakeRecord) UpdateCallCount() int {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	return len(fake.updateArgsForCall)
}

func (fake *FakeRecord) UpdateArgsForCall(i int) (string, []release.Release) {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	return fake.updateArgsForCall[i].manifestSHA, fake.updateArgsForCall[i].releases
}

func (fake *FakeRecord) UpdateReturns(result1 error) {
	fake.UpdateStub = nil
	fake.updateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRecord) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.isDeployedMutex.RLock()
	defer fake.isDeployedMutex.RUnlock()
	fake.clearMutex.RLock()
	defer fake.clearMutex.RUnlock()
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeRecord) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ deployment.Record = new(FakeRecord)
