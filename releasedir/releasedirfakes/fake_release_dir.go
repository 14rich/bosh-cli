// This file was generated by counterfeiter
package releasedirfakes

import (
	"sync"

	birel "github.com/cloudfoundry/bosh-cli/release"
	"github.com/cloudfoundry/bosh-cli/releasedir"
	gssver "github.com/cppforlife/go-semi-semantic/version"
)

type FakeReleaseDir struct {
	InitStub        func(bool) error
	initMutex       sync.RWMutex
	initArgsForCall []struct {
		arg1 bool
	}
	initReturns struct {
		result1 error
	}
	ResetStub        func() error
	resetMutex       sync.RWMutex
	resetArgsForCall []struct{}
	resetReturns     struct {
		result1 error
	}
	GenerateJobStub        func(string) error
	generateJobMutex       sync.RWMutex
	generateJobArgsForCall []struct {
		arg1 string
	}
	generateJobReturns struct {
		result1 error
	}
	GeneratePackageStub        func(string) error
	generatePackageMutex       sync.RWMutex
	generatePackageArgsForCall []struct {
		arg1 string
	}
	generatePackageReturns struct {
		result1 error
	}
	DefaultNameStub        func() (string, error)
	defaultNameMutex       sync.RWMutex
	defaultNameArgsForCall []struct{}
	defaultNameReturns     struct {
		result1 string
		result2 error
	}
	NextDevVersionStub        func(name string, timestamp bool) (gssver.Version, error)
	nextDevVersionMutex       sync.RWMutex
	nextDevVersionArgsForCall []struct {
		name      string
		timestamp bool
	}
	nextDevVersionReturns struct {
		result1 gssver.Version
		result2 error
	}
	NextFinalVersionStub        func(name string) (gssver.Version, error)
	nextFinalVersionMutex       sync.RWMutex
	nextFinalVersionArgsForCall []struct {
		name string
	}
	nextFinalVersionReturns struct {
		result1 gssver.Version
		result2 error
	}
	LastReleaseStub        func() (birel.Release, error)
	lastReleaseMutex       sync.RWMutex
	lastReleaseArgsForCall []struct{}
	lastReleaseReturns     struct {
		result1 birel.Release
		result2 error
	}
	BuildReleaseStub        func(name string, version gssver.Version, force bool) (birel.Release, error)
	buildReleaseMutex       sync.RWMutex
	buildReleaseArgsForCall []struct {
		name    string
		version gssver.Version
		force   bool
	}
	buildReleaseReturns struct {
		result1 birel.Release
		result2 error
	}
	FinalizeReleaseStub        func(release birel.Release, force bool) error
	finalizeReleaseMutex       sync.RWMutex
	finalizeReleaseArgsForCall []struct {
		release birel.Release
		force   bool
	}
	finalizeReleaseReturns struct {
		result1 error
	}
	BuildReleaseArchiveStub        func(birel.Release) (string, error)
	buildReleaseArchiveMutex       sync.RWMutex
	buildReleaseArchiveArgsForCall []struct {
		arg1 birel.Release
	}
	buildReleaseArchiveReturns struct {
		result1 string
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeReleaseDir) Init(arg1 bool) error {
	fake.initMutex.Lock()
	fake.initArgsForCall = append(fake.initArgsForCall, struct {
		arg1 bool
	}{arg1})
	fake.recordInvocation("Init", []interface{}{arg1})
	fake.initMutex.Unlock()
	if fake.InitStub != nil {
		return fake.InitStub(arg1)
	} else {
		return fake.initReturns.result1
	}
}

func (fake *FakeReleaseDir) InitCallCount() int {
	fake.initMutex.RLock()
	defer fake.initMutex.RUnlock()
	return len(fake.initArgsForCall)
}

func (fake *FakeReleaseDir) InitArgsForCall(i int) bool {
	fake.initMutex.RLock()
	defer fake.initMutex.RUnlock()
	return fake.initArgsForCall[i].arg1
}

func (fake *FakeReleaseDir) InitReturns(result1 error) {
	fake.InitStub = nil
	fake.initReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeReleaseDir) Reset() error {
	fake.resetMutex.Lock()
	fake.resetArgsForCall = append(fake.resetArgsForCall, struct{}{})
	fake.recordInvocation("Reset", []interface{}{})
	fake.resetMutex.Unlock()
	if fake.ResetStub != nil {
		return fake.ResetStub()
	} else {
		return fake.resetReturns.result1
	}
}

func (fake *FakeReleaseDir) ResetCallCount() int {
	fake.resetMutex.RLock()
	defer fake.resetMutex.RUnlock()
	return len(fake.resetArgsForCall)
}

func (fake *FakeReleaseDir) ResetReturns(result1 error) {
	fake.ResetStub = nil
	fake.resetReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeReleaseDir) GenerateJob(arg1 string) error {
	fake.generateJobMutex.Lock()
	fake.generateJobArgsForCall = append(fake.generateJobArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("GenerateJob", []interface{}{arg1})
	fake.generateJobMutex.Unlock()
	if fake.GenerateJobStub != nil {
		return fake.GenerateJobStub(arg1)
	} else {
		return fake.generateJobReturns.result1
	}
}

func (fake *FakeReleaseDir) GenerateJobCallCount() int {
	fake.generateJobMutex.RLock()
	defer fake.generateJobMutex.RUnlock()
	return len(fake.generateJobArgsForCall)
}

func (fake *FakeReleaseDir) GenerateJobArgsForCall(i int) string {
	fake.generateJobMutex.RLock()
	defer fake.generateJobMutex.RUnlock()
	return fake.generateJobArgsForCall[i].arg1
}

func (fake *FakeReleaseDir) GenerateJobReturns(result1 error) {
	fake.GenerateJobStub = nil
	fake.generateJobReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeReleaseDir) GeneratePackage(arg1 string) error {
	fake.generatePackageMutex.Lock()
	fake.generatePackageArgsForCall = append(fake.generatePackageArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("GeneratePackage", []interface{}{arg1})
	fake.generatePackageMutex.Unlock()
	if fake.GeneratePackageStub != nil {
		return fake.GeneratePackageStub(arg1)
	} else {
		return fake.generatePackageReturns.result1
	}
}

func (fake *FakeReleaseDir) GeneratePackageCallCount() int {
	fake.generatePackageMutex.RLock()
	defer fake.generatePackageMutex.RUnlock()
	return len(fake.generatePackageArgsForCall)
}

func (fake *FakeReleaseDir) GeneratePackageArgsForCall(i int) string {
	fake.generatePackageMutex.RLock()
	defer fake.generatePackageMutex.RUnlock()
	return fake.generatePackageArgsForCall[i].arg1
}

func (fake *FakeReleaseDir) GeneratePackageReturns(result1 error) {
	fake.GeneratePackageStub = nil
	fake.generatePackageReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeReleaseDir) DefaultName() (string, error) {
	fake.defaultNameMutex.Lock()
	fake.defaultNameArgsForCall = append(fake.defaultNameArgsForCall, struct{}{})
	fake.recordInvocation("DefaultName", []interface{}{})
	fake.defaultNameMutex.Unlock()
	if fake.DefaultNameStub != nil {
		return fake.DefaultNameStub()
	} else {
		return fake.defaultNameReturns.result1, fake.defaultNameReturns.result2
	}
}

func (fake *FakeReleaseDir) DefaultNameCallCount() int {
	fake.defaultNameMutex.RLock()
	defer fake.defaultNameMutex.RUnlock()
	return len(fake.defaultNameArgsForCall)
}

func (fake *FakeReleaseDir) DefaultNameReturns(result1 string, result2 error) {
	fake.DefaultNameStub = nil
	fake.defaultNameReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeReleaseDir) NextDevVersion(name string, timestamp bool) (gssver.Version, error) {
	fake.nextDevVersionMutex.Lock()
	fake.nextDevVersionArgsForCall = append(fake.nextDevVersionArgsForCall, struct {
		name      string
		timestamp bool
	}{name, timestamp})
	fake.recordInvocation("NextDevVersion", []interface{}{name, timestamp})
	fake.nextDevVersionMutex.Unlock()
	if fake.NextDevVersionStub != nil {
		return fake.NextDevVersionStub(name, timestamp)
	} else {
		return fake.nextDevVersionReturns.result1, fake.nextDevVersionReturns.result2
	}
}

func (fake *FakeReleaseDir) NextDevVersionCallCount() int {
	fake.nextDevVersionMutex.RLock()
	defer fake.nextDevVersionMutex.RUnlock()
	return len(fake.nextDevVersionArgsForCall)
}

func (fake *FakeReleaseDir) NextDevVersionArgsForCall(i int) (string, bool) {
	fake.nextDevVersionMutex.RLock()
	defer fake.nextDevVersionMutex.RUnlock()
	return fake.nextDevVersionArgsForCall[i].name, fake.nextDevVersionArgsForCall[i].timestamp
}

func (fake *FakeReleaseDir) NextDevVersionReturns(result1 gssver.Version, result2 error) {
	fake.NextDevVersionStub = nil
	fake.nextDevVersionReturns = struct {
		result1 gssver.Version
		result2 error
	}{result1, result2}
}

func (fake *FakeReleaseDir) NextFinalVersion(name string) (gssver.Version, error) {
	fake.nextFinalVersionMutex.Lock()
	fake.nextFinalVersionArgsForCall = append(fake.nextFinalVersionArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("NextFinalVersion", []interface{}{name})
	fake.nextFinalVersionMutex.Unlock()
	if fake.NextFinalVersionStub != nil {
		return fake.NextFinalVersionStub(name)
	} else {
		return fake.nextFinalVersionReturns.result1, fake.nextFinalVersionReturns.result2
	}
}

func (fake *FakeReleaseDir) NextFinalVersionCallCount() int {
	fake.nextFinalVersionMutex.RLock()
	defer fake.nextFinalVersionMutex.RUnlock()
	return len(fake.nextFinalVersionArgsForCall)
}

func (fake *FakeReleaseDir) NextFinalVersionArgsForCall(i int) string {
	fake.nextFinalVersionMutex.RLock()
	defer fake.nextFinalVersionMutex.RUnlock()
	return fake.nextFinalVersionArgsForCall[i].name
}

func (fake *FakeReleaseDir) NextFinalVersionReturns(result1 gssver.Version, result2 error) {
	fake.NextFinalVersionStub = nil
	fake.nextFinalVersionReturns = struct {
		result1 gssver.Version
		result2 error
	}{result1, result2}
}

func (fake *FakeReleaseDir) LastRelease() (birel.Release, error) {
	fake.lastReleaseMutex.Lock()
	fake.lastReleaseArgsForCall = append(fake.lastReleaseArgsForCall, struct{}{})
	fake.recordInvocation("LastRelease", []interface{}{})
	fake.lastReleaseMutex.Unlock()
	if fake.LastReleaseStub != nil {
		return fake.LastReleaseStub()
	} else {
		return fake.lastReleaseReturns.result1, fake.lastReleaseReturns.result2
	}
}

func (fake *FakeReleaseDir) LastReleaseCallCount() int {
	fake.lastReleaseMutex.RLock()
	defer fake.lastReleaseMutex.RUnlock()
	return len(fake.lastReleaseArgsForCall)
}

func (fake *FakeReleaseDir) LastReleaseReturns(result1 birel.Release, result2 error) {
	fake.LastReleaseStub = nil
	fake.lastReleaseReturns = struct {
		result1 birel.Release
		result2 error
	}{result1, result2}
}

func (fake *FakeReleaseDir) BuildRelease(name string, version gssver.Version, force bool) (birel.Release, error) {
	fake.buildReleaseMutex.Lock()
	fake.buildReleaseArgsForCall = append(fake.buildReleaseArgsForCall, struct {
		name    string
		version gssver.Version
		force   bool
	}{name, version, force})
	fake.recordInvocation("BuildRelease", []interface{}{name, version, force})
	fake.buildReleaseMutex.Unlock()
	if fake.BuildReleaseStub != nil {
		return fake.BuildReleaseStub(name, version, force)
	} else {
		return fake.buildReleaseReturns.result1, fake.buildReleaseReturns.result2
	}
}

func (fake *FakeReleaseDir) BuildReleaseCallCount() int {
	fake.buildReleaseMutex.RLock()
	defer fake.buildReleaseMutex.RUnlock()
	return len(fake.buildReleaseArgsForCall)
}

func (fake *FakeReleaseDir) BuildReleaseArgsForCall(i int) (string, gssver.Version, bool) {
	fake.buildReleaseMutex.RLock()
	defer fake.buildReleaseMutex.RUnlock()
	return fake.buildReleaseArgsForCall[i].name, fake.buildReleaseArgsForCall[i].version, fake.buildReleaseArgsForCall[i].force
}

func (fake *FakeReleaseDir) BuildReleaseReturns(result1 birel.Release, result2 error) {
	fake.BuildReleaseStub = nil
	fake.buildReleaseReturns = struct {
		result1 birel.Release
		result2 error
	}{result1, result2}
}

func (fake *FakeReleaseDir) FinalizeRelease(release birel.Release, force bool) error {
	fake.finalizeReleaseMutex.Lock()
	fake.finalizeReleaseArgsForCall = append(fake.finalizeReleaseArgsForCall, struct {
		release birel.Release
		force   bool
	}{release, force})
	fake.recordInvocation("FinalizeRelease", []interface{}{release, force})
	fake.finalizeReleaseMutex.Unlock()
	if fake.FinalizeReleaseStub != nil {
		return fake.FinalizeReleaseStub(release, force)
	} else {
		return fake.finalizeReleaseReturns.result1
	}
}

func (fake *FakeReleaseDir) FinalizeReleaseCallCount() int {
	fake.finalizeReleaseMutex.RLock()
	defer fake.finalizeReleaseMutex.RUnlock()
	return len(fake.finalizeReleaseArgsForCall)
}

func (fake *FakeReleaseDir) FinalizeReleaseArgsForCall(i int) (birel.Release, bool) {
	fake.finalizeReleaseMutex.RLock()
	defer fake.finalizeReleaseMutex.RUnlock()
	return fake.finalizeReleaseArgsForCall[i].release, fake.finalizeReleaseArgsForCall[i].force
}

func (fake *FakeReleaseDir) FinalizeReleaseReturns(result1 error) {
	fake.FinalizeReleaseStub = nil
	fake.finalizeReleaseReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeReleaseDir) BuildReleaseArchive(arg1 birel.Release) (string, error) {
	fake.buildReleaseArchiveMutex.Lock()
	fake.buildReleaseArchiveArgsForCall = append(fake.buildReleaseArchiveArgsForCall, struct {
		arg1 birel.Release
	}{arg1})
	fake.recordInvocation("BuildReleaseArchive", []interface{}{arg1})
	fake.buildReleaseArchiveMutex.Unlock()
	if fake.BuildReleaseArchiveStub != nil {
		return fake.BuildReleaseArchiveStub(arg1)
	} else {
		return fake.buildReleaseArchiveReturns.result1, fake.buildReleaseArchiveReturns.result2
	}
}

func (fake *FakeReleaseDir) BuildReleaseArchiveCallCount() int {
	fake.buildReleaseArchiveMutex.RLock()
	defer fake.buildReleaseArchiveMutex.RUnlock()
	return len(fake.buildReleaseArchiveArgsForCall)
}

func (fake *FakeReleaseDir) BuildReleaseArchiveArgsForCall(i int) birel.Release {
	fake.buildReleaseArchiveMutex.RLock()
	defer fake.buildReleaseArchiveMutex.RUnlock()
	return fake.buildReleaseArchiveArgsForCall[i].arg1
}

func (fake *FakeReleaseDir) BuildReleaseArchiveReturns(result1 string, result2 error) {
	fake.BuildReleaseArchiveStub = nil
	fake.buildReleaseArchiveReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeReleaseDir) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.initMutex.RLock()
	defer fake.initMutex.RUnlock()
	fake.resetMutex.RLock()
	defer fake.resetMutex.RUnlock()
	fake.generateJobMutex.RLock()
	defer fake.generateJobMutex.RUnlock()
	fake.generatePackageMutex.RLock()
	defer fake.generatePackageMutex.RUnlock()
	fake.defaultNameMutex.RLock()
	defer fake.defaultNameMutex.RUnlock()
	fake.nextDevVersionMutex.RLock()
	defer fake.nextDevVersionMutex.RUnlock()
	fake.nextFinalVersionMutex.RLock()
	defer fake.nextFinalVersionMutex.RUnlock()
	fake.lastReleaseMutex.RLock()
	defer fake.lastReleaseMutex.RUnlock()
	fake.buildReleaseMutex.RLock()
	defer fake.buildReleaseMutex.RUnlock()
	fake.finalizeReleaseMutex.RLock()
	defer fake.finalizeReleaseMutex.RUnlock()
	fake.buildReleaseArchiveMutex.RLock()
	defer fake.buildReleaseArchiveMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeReleaseDir) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ releasedir.ReleaseDir = new(FakeReleaseDir)
